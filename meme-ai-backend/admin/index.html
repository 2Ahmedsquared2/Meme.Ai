<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meme.AI Admin</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #000000;
            --card-bg: #1C1C1E;
            --card-hover: #2C2C2E;
            --text-primary: #FFFFFF;
            --text-secondary: #8E8E93;
            --border: #38383A;

            --primary: #0A84FF;
            --primary-hover: #0071E3;
            --danger: #FF453A;
            --danger-hover: #D70015;
            --success: #30D158;
            --success-hover: #248A3D;

            /* Frontend Tag Category Colors */
            --tag-emotion: #BF5AF2;
            --tag-source: #0A84FF;
            --tag-format: #30D158;
            --tag-tone: #FF9F0A;
            --tag-situation: #FF453A;
            --tag-subject: #5AC8FA;
            --tag-vibe: #FF6B6B;
            --tag-gemini: #FF9F0A;
            --tag-custom: #8E8E93;

            --radius: 12px;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg);
            color: var(--text-primary);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .navbar {
            background: rgba(28, 28, 30, 0.8);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--border);
            padding: 0 24px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            z-index: 100;
        }

        .logo { font-weight: 700; font-size: 18px; display: flex; align-items: center; gap: 8px; }
        .nav-links { display: flex; gap: 24px; }
        .nav-item {
            cursor: pointer;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            color: var(--text-secondary);
            transition: all 0.2s;
        }
        .nav-item:hover { color: var(--text-primary); background: rgba(255, 255, 255, 0.1); }
        .nav-item.active { color: var(--primary); background: rgba(10, 132, 255, 0.15); }

        .main-content {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
        }

        .view { display: none; height: 100%; }
        .view.active { display: flex; flex-direction: column; }

        .pending-container {
            display: grid;
            grid-template-columns: 1fr 550px;
            gap: 24px;
            height: 100%;
            max-height: 850px;
        }

        .image-section {
            background: var(--card-bg);
            border-radius: var(--radius);
            border: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 24px;
            position: relative;
        }

        .meme-image { width: 100%; height: 100%; object-fit: contain; border-radius: 8px; }

        .controls-section {
            background: var(--card-bg);
            border-radius: var(--radius);
            border: 1px solid var(--border);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            overflow-y: auto;
        }

        /* Section Headers */
        .section-header {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .section-divider {
            border-top: 1px solid var(--border);
            padding-top: 16px;
            margin-top: 8px;
        }

        /* Tags Container */
        .tags-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            min-height: 32px;
        }

        .tag {
            font-size: 12px;
            padding: 5px 10px;
            border-radius: 6px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            cursor: default;
            border: 1px solid transparent;
        }

        .tag-remove {
            cursor: pointer;
            opacity: 0.6;
            font-weight: bold;
            padding: 0 2px;
            font-size: 14px;
        }
        .tag-remove:hover { opacity: 1; color: white; }

        /* Gemini Tags (Orange/Amber) */
        .tag-gemini {
            background: rgba(255, 159, 10, 0.15);
            color: #FF9F0A;
            border-color: rgba(255, 159, 10, 0.3);
        }

        /* Frontend Tag Colors */
        .tag-emotion { background: rgba(191, 90, 242, 0.2); color: #BF5AF2; border-color: rgba(191, 90, 242, 0.4); }
        .tag-source { background: rgba(10, 132, 255, 0.2); color: #0A84FF; border-color: rgba(10, 132, 255, 0.4); }
        .tag-format { background: rgba(48, 209, 88, 0.2); color: #30D158; border-color: rgba(48, 209, 88, 0.4); }
        .tag-tone { background: rgba(255, 159, 10, 0.2); color: #FF9F0A; border-color: rgba(255, 159, 10, 0.4); }
        .tag-situation { background: rgba(255, 69, 58, 0.2); color: #FF6961; border-color: rgba(255, 69, 58, 0.4); }
        .tag-subject { background: rgba(90, 200, 250, 0.2); color: #5AC8FA; border-color: rgba(90, 200, 250, 0.4); }
        .tag-vibe { background: rgba(255, 107, 107, 0.2); color: #FF6B6B; border-color: rgba(255, 107, 107, 0.4); }
        .tag-custom { background: rgba(142, 142, 147, 0.2); color: #AEAEB2; border-color: rgba(142, 142, 147, 0.4); }
        
        /* Custom tags display - Cyan/Teal to differentiate from Gemini orange */
        .tag-custom-display {
            background: rgba(100, 210, 255, 0.2);
            color: #64D2FF;
            border-color: rgba(100, 210, 255, 0.4);
        }

        /* Meme Type Toggle */
        .meme-type-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 10px;
            margin-bottom: 16px;
            border: 1px solid var(--border);
            flex-wrap: wrap;
        }
        .type-btn {
            padding: 8px 14px;
            border: 2px solid var(--border);
            border-radius: 8px;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        .type-btn:hover {
            background: rgba(255, 255, 255, 0.05);
            border-color: var(--text-secondary);
        }
        .type-btn.active {
            color: white;
        }
        .type-btn.active.customizable {
            background: #30D158;
            border-color: #30D158;
        }
        .type-btn.active.rec_engine {
            background: #FF9F0A;
            border-color: #FF9F0A;
        }
        .type-btn.active.both {
            background: #5E5CE6;
            border-color: #5E5CE6;
        }
        
        /* Approved Gallery Filters */
        .approved-filters {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
            flex-wrap: wrap;
            align-items: center;
        }
        .filter-btn {
            padding: 6px 12px;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }
        .filter-btn:hover {
            background: rgba(255, 255, 255, 0.05);
        }
        .filter-btn.active {
            background: var(--primary);
            border-color: var(--primary);
            color: white;
        }
        .filter-label {
            font-size: 12px;
            color: var(--text-secondary);
            margin-right: 4px;
        }

        /* Use Case Section */
        .use-case-box {
            background: #2C2C2E;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            font-size: 13px;
            line-height: 1.5;
            color: var(--text-primary);
        }

        .use-case-display {
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }

        .use-case-text { flex: 1; }

        .use-case-input {
            flex: 1;
            background: #2C2C2E;
            border: 1px solid var(--primary);
            border-radius: 6px;
            padding: 8px;
            font-size: 13px;
            color: white;
            font-family: inherit;
            resize: vertical;
            min-height: 60px;
        }

        .edit-btn {
            background: #3A3A3C;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            color: var(--text-secondary);
            white-space: nowrap;
        }
        .edit-btn:hover { background: #48484A; color: white; }

        /* Category Dropdowns */
        .category-filters { display: flex; flex-wrap: wrap; gap: 8px; }

        .category-btn-wrapper { position: relative; }

        .category-btn {
            padding: 6px 12px;
            border: 1px solid var(--border);
            border-radius: 6px;
            color: white;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            transition: all 0.2s;
        }
        .category-btn::after { content: '‚ñº'; font-size: 8px; opacity: 0.6; margin-left: 4px; }
        .category-btn:hover { filter: brightness(1.1); }

        /* Colored Category Buttons */
        .cat-btn-emotion { background: rgba(191, 90, 242, 0.3); border-color: rgba(191, 90, 242, 0.5); }
        .cat-btn-source { background: rgba(10, 132, 255, 0.3); border-color: rgba(10, 132, 255, 0.5); }
        .cat-btn-format { background: rgba(48, 209, 88, 0.3); border-color: rgba(48, 209, 88, 0.5); }
        .cat-btn-tone { background: rgba(255, 159, 10, 0.3); border-color: rgba(255, 159, 10, 0.5); }
        .cat-btn-situation { background: rgba(255, 69, 58, 0.3); border-color: rgba(255, 69, 58, 0.5); }
        .cat-btn-subject { background: rgba(90, 200, 250, 0.3); border-color: rgba(90, 200, 250, 0.5); }
        .cat-btn-vibe { background: rgba(255, 107, 107, 0.3); border-color: rgba(255, 107, 107, 0.5); }
        .cat-btn-custom { background: rgba(142, 142, 147, 0.3); border-color: rgba(142, 142, 147, 0.5); }

        .category-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 6px;
            background: #1C1C1E;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 8px;
            width: 200px;
            max-height: 250px;
            overflow-y: auto;
            z-index: 500;
            display: none;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
        }
        .category-dropdown.show { display: block; }

        .dropdown-item {
            padding: 6px 10px;
            font-size: 12px;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 4px;
        }
        .dropdown-item:hover { background: var(--primary); color: white; }

        /* Inputs */
        input[type="text"] {
            flex: 1;
            padding: 8px 10px;
            background: #2C2C2E;
            border: 1px solid var(--border);
            color: white;
            border-radius: 6px;
            font-size: 13px;
            font-family: inherit;
        }
        input[type="text"]:focus { outline: none; border-color: var(--primary); }

        .input-group { display: flex; gap: 8px; }

        .suggested-tags-area {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            padding: 10px;
            background: #1C1C1E;
            border: 1px solid var(--border);
            border-radius: 8px;
            max-height: 150px;
            overflow-y: auto;
        }

        .preset-tag {
            font-size: 11px;
            padding: 4px 8px;
            background: #3A3A3C;
            border: 1px solid var(--border);
            border-radius: 4px;
            cursor: pointer;
            color: var(--text-secondary);
        }
        .preset-tag:hover { border-color: var(--primary); color: var(--primary); }

        /* Action Buttons */
        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 13px;
            cursor: pointer;
            transition: transform 0.1s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        .btn:active { transform: scale(0.98); }
        .btn-primary { background: var(--primary); color: white; }
        .btn-primary:hover { background: var(--primary-hover); }
        .btn-danger { background: var(--danger); color: white; }
        .btn-danger:hover { background: var(--danger-hover); }
        .btn-success { background: var(--success); color: white; }
        .btn-success:hover { background: var(--success-hover); }
        .btn-secondary { background: #3A3A3C; color: white; }
        .btn-secondary:hover { background: #48484A; }

        .action-bar {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
            margin-top: auto;
            padding-top: 16px;
            border-top: 1px solid var(--border);
        }

        /* Progress indicator */
        .progress-indicator { font-size: 12px; color: var(--text-secondary); }

        /* Grid & Cards for Approved */
        .filter-section {
            background: var(--card-bg);
            padding: 20px;
            border-radius: var(--radius);
            border: 1px solid var(--border);
            margin-bottom: 24px;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            gap: 20px;
            padding-bottom: 40px;
        }

        .meme-card {
            background: var(--card-bg);
            border-radius: var(--radius);
            overflow: hidden;
            border: 1px solid var(--border);
            cursor: pointer;
            transition: transform 0.2s, border-color 0.2s;
        }
        .meme-card:hover { transform: translateY(-4px); border-color: var(--primary); }

        .card-img { height: 180px; width: 100%; object-fit: cover; background: #2C2C2E; }
        .card-body { padding: 12px; }
        .card-meta { font-size: 11px; color: var(--text-secondary); margin-bottom: 6px; display: flex; justify-content: space-between; }
        .card-tags { display: flex; gap: 4px; overflow: hidden; }
        .mini-tag { font-size: 9px; padding: 2px 5px; background: #3A3A3C; border-radius: 3px; color: #E5E5EA; }

        /* Modal */
        .modal-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
        }
        .modal-overlay.active { display: flex; }

        .modal-content {
            background: black;
            width: 90%;
            max-width: 1200px;
            height: 90vh;
            border-radius: var(--radius);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            position: relative;
            border: 1px solid var(--border);
        }

        .modal-close {
            position: absolute; top: 16px; right: 16px; z-index: 10;
            background: #3A3A3C; border-radius: 50%; width: 32px; height: 32px;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; color: white;
        }
        .modal-close:hover { background: #48484A; }

        /* States */
        .state-message {
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            height: 100%; color: var(--text-secondary); gap: 16px;
        }

        .spinner {
            width: 40px; height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Toast */
        .toast {
            position: fixed; bottom: 24px; left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: #3A3A3C; color: white;
            padding: 12px 24px; border-radius: 50px;
            font-size: 14px; font-weight: 500;
            opacity: 0; transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            z-index: 2000; border: 1px solid var(--border);
        }
        .toast.show { transform: translateX(-50%) translateY(0); opacity: 1; }

        .active-filters { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 12px; min-height: 32px; padding-top: 12px; border-top: 1px solid var(--border); }
        .filter-tag { background: var(--primary); color: white; padding: 4px 10px; border-radius: 20px; font-size: 12px; display: flex; align-items: center; gap: 6px; }
    </style>
</head>

<body>
    <nav class="navbar">
        <div class="logo"><span>üé≠</span> Meme.AI Admin</div>
        <div class="nav-links">
            <div class="nav-item active" onclick="app.switchView('pending')">
                Pending Review <span id="pendingCount" style="opacity: 0.6; margin-left: 4px">(0)</span>
            </div>
            <div class="nav-item" onclick="app.switchView('approved')">
                Approved Gallery <span id="approvedCount" style="opacity: 0.6; margin-left: 4px">(0)</span>
            </div>
            <div class="nav-item" onclick="app.switchView('tags')">Tags</div>
        </div>
        <div style="font-size: 12px; color: var(--text-secondary);">
            API: <span id="apiUrlDisplay">http://localhost:8000</span>
        </div>
    </nav>

    <main class="main-content">
        <!-- PENDING VIEW -->
        <div id="pendingView" class="view active">
            <div id="pendingLoading" class="state-message">
                <div class="spinner"></div>
                <p>Loading pending memes...</p>
            </div>

            <div id="pendingEmpty" class="state-message" style="display: none;">
                <div style="font-size: 48px;">üéâ</div>
                <p>All caught up! No pending memes.</p>
                <button class="btn btn-secondary" onclick="app.loadMemes()">Refresh</button>
            </div>

            <div id="pendingContent" class="pending-container" style="display: none;">
                <div class="image-section">
                    <img id="currentMemeImage" class="meme-image" src="" alt="Meme">
                    <div style="position: absolute; top: 16px; left: 16px; background: rgba(0,0,0,0.6); color: white; padding: 4px 8px; border-radius: 6px; font-size: 12px;">
                        ID: <span id="currentMemeId">...</span>
                    </div>
                </div>
                <div id="pendingControls" class="controls-section"></div>
            </div>
        </div>

        <!-- APPROVED VIEW -->
        <div id="approvedView" class="view">
            <div class="filter-section">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                    <h3 style="font-size: 16px; font-weight: 600;">Filter by Frontend Tags</h3>
                    <button class="btn btn-secondary" onclick="app.loadMemes()" style="padding: 6px 12px; font-size: 12px;">üîÑ Refresh</button>
                </div>

                <div id="categoryFilters" class="category-filters"></div>

                <div class="input-group" style="margin: 16px 0;">
                    <input type="text" id="tagSearchInput" placeholder="Search frontend tags..." autocomplete="off">
                </div>

                <div id="suggestedTags" class="suggested-tags-area" style="display: none; margin-bottom: 16px;"></div>

                <div id="activeFilters" class="active-filters"></div>
                </div>

            <!-- Approved Gallery Filters -->
            <div class="approved-filters">
                <span class="filter-label">Show:</span>
                <button class="filter-btn active" onclick="app.setApprovedFilter('all')">All</button>
                <button class="filter-btn" onclick="app.setApprovedFilter('last1')">Last 1</button>
                <button class="filter-btn" onclick="app.setApprovedFilter('last5')">Last 5</button>
                <button class="filter-btn" onclick="app.setApprovedFilter('last10')">Last 10</button>
                <span class="filter-label" style="margin-left: 12px;">Type:</span>
                <button class="filter-btn" onclick="app.setApprovedFilter('customizable')">üé® Customizable</button>
                <button class="filter-btn" onclick="app.setApprovedFilter('rec_engine')">üöÄ Rec Engine</button>
                <button class="filter-btn" onclick="app.setApprovedFilter('both')">‚ö° Both</button>
                </div>

            <div id="approvedGrid" class="grid-container"></div>
            </div>

        <!-- TAGS VIEW -->
        <div id="tagsView" class="view">
            <div class="filter-section">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                    <h3 style="font-size: 16px; font-weight: 600;">Manage Custom Tags</h3>
                    <button class="btn btn-danger" onclick="app.clearAllCustomTags()" style="padding: 6px 12px; font-size: 12px;">üóëÔ∏è Clear All</button>
                </div>
                <p style="font-size: 13px; color: var(--text-secondary); margin-bottom: 24px;">
                    Custom tags you've manually added.
                </p>
                <div id="customTagsList" style="display: flex; flex-wrap: wrap; gap: 8px;"></div>
                </div>
            </div>
    </main>

    <!-- EDIT MODAL -->
    <div id="editModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-close" onclick="app.closeModal()">√ó</div>
            <div class="pending-container" style="padding: 24px; height: 100%;">
                <div class="image-section">
                    <img id="modalMemeImage" class="meme-image" src="" alt="Meme">
                </div>
                <div id="modalControls" class="controls-section"></div>
            </div>
        </div>
    </div>

    <div id="toast" class="toast">Action Successful</div>

    <script>
        const API_BASE = 'http://localhost:8000';

        // Frontend tag categories with their colors
        const FRONTEND_CATEGORIES = {
            'emotion': { label: 'üòä Emotion', btnClass: 'cat-btn-emotion', tagClass: 'tag-emotion' },
            'source': { label: 'üé¨ Source', btnClass: 'cat-btn-source', tagClass: 'tag-source' },
            'format': { label: 'üñºÔ∏è Format', btnClass: 'cat-btn-format', tagClass: 'tag-format' },
            'tone': { label: 'üé≠ Tone', btnClass: 'cat-btn-tone', tagClass: 'tag-tone' },
            'situation': { label: 'üíº Situation', btnClass: 'cat-btn-situation', tagClass: 'tag-situation' },
            'subject': { label: 'üë§ Subject', btnClass: 'cat-btn-subject', tagClass: 'tag-subject' },
            'vibe': { label: '‚ö° Vibe', btnClass: 'cat-btn-vibe', tagClass: 'tag-vibe' },
        };

        const app = {
            state: {
                pendingMemes: [],
                approvedMemes: [],
                currentIndex: 0,
                currentMeme: null,
                isModalOpen: false,
                tempGeminiTags: [],
                tempFrontendTags: {},
                tempCustomTags: [],
                tempUseCase: '',
                tempMemeType: 'rec_engine',  // 'customizable', 'rec_engine', or 'both'
                isEditingUseCase: false,
                approvedFilter: 'all',  // 'all', 'last1', 'last5', 'last10', 'customizable', 'rec_engine', 'both'
                frontendTagOptions: {},
                customTags: [],
                allFrontendTags: new Set(),
                activeFilters: [],
            },

            async init() {
                // Load tags from backend first
                await Promise.all([
                    this.loadCustomTags(),
                    this.loadFrontendTags()
                ]);
                
                // Then load memes
                this.loadMemes();

                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.category-btn-wrapper')) {
                        document.querySelectorAll('.category-dropdown').forEach(el => el.classList.remove('show'));
                    }
                });

                document.getElementById('tagSearchInput')?.addEventListener('input', (e) => {
                        this.searchFilterTags(e.target.value);
                });
            },

            switchView(viewName) {
                document.querySelectorAll('.view').forEach(el => el.classList.remove('active'));
                document.querySelectorAll('.nav-item').forEach(el => el.classList.remove('active'));
                document.getElementById(`${viewName}View`).classList.add('active');

                const navItems = document.querySelectorAll('.nav-item');
                if (viewName === 'pending') navItems[0].classList.add('active');
                else if (viewName === 'approved') navItems[1].classList.add('active');
                else if (viewName === 'tags') { navItems[2].classList.add('active'); this.renderTagsView(); }
            },

            async loadMemes() {
                try {
                    document.getElementById('pendingLoading').style.display = 'flex';

                    const [pendingRes, pendingAnalysisRes, approvedRes] = await Promise.all([
                        fetch(`${API_BASE}/memes?status=pending&limit=100&include_all_types=true`),
                        fetch(`${API_BASE}/memes?status=pending_analysis&limit=100&include_all_types=true`),
                        fetch(`${API_BASE}/memes?status=approved&limit=1000&include_all_types=true`)
                    ]);

                    const pendingMemes = (await pendingRes.json()).memes || [];
                    const pendingAnalysisMemes = (await pendingAnalysisRes.json()).memes || [];
                    // Combine both - pending_analysis memes are still being processed by Gemini
                    this.state.pendingMemes = [...pendingAnalysisMemes, ...pendingMemes];
                    this.state.approvedMemes = (await approvedRes.json()).memes || [];

                    document.getElementById('pendingCount').textContent = `(${this.state.pendingMemes.length})`;
                    document.getElementById('approvedCount').textContent = `(${this.state.approvedMemes.length})`;

                    if (this.state.pendingMemes.length > 0) {
                        this.state.currentIndex = 0;
                        this.loadPendingMemeUI();
                        document.getElementById('pendingContent').style.display = 'grid';
                        document.getElementById('pendingEmpty').style.display = 'none';
                    } else {
                        document.getElementById('pendingContent').style.display = 'none';
                        document.getElementById('pendingEmpty').style.display = 'flex';
                    }
                    document.getElementById('pendingLoading').style.display = 'none';

                    this.applyFilters();
                } catch (err) {
                    console.error(err);
                    this.showToast('Error loading memes: ' + err.message, true);
                }
            },

            async loadCustomTags() {
                try {
                    const res = await fetch(`${API_BASE}/tags/custom`);
                    const data = await res.json();
                        this.state.customTags = data.tags || [];
                } catch (err) {
                    console.error('Failed to load custom tags:', err);
                            this.state.customTags = [];
                        }
            },

            async loadFrontendTags() {
                try {
                    const res = await fetch(`${API_BASE}/tags/frontend`);
                    if (res.ok) {
                        const data = await res.json();
                        // Convert { category: { description, tags } } to { category: [tags] }
                        for (const [cat, info] of Object.entries(data)) {
                            this.state.frontendTagOptions[cat] = info.tags || [];
                            (info.tags || []).forEach(t => this.state.allFrontendTags.add(t));
                        }
                        this.renderCategoryButtons();
                    }
                } catch (err) { console.error('Failed to load frontend tags:', err); }
            },

            async saveCustomTag(tag) {
                if (!this.state.customTags.includes(tag)) {
                    this.state.customTags.push(tag);
                    try {
                        await fetch(`${API_BASE}/tags/custom`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(this.state.customTags)
                    });
                    } catch (err) {
                        console.error('Failed to save custom tag:', err);
                    }
                }
            },

            // ================= CONTROLS RENDERING =================

            initTempData(meme) {
                // Gemini tags = visual_tags + contextual_tags combined
                this.state.tempGeminiTags = [...(meme.visual_tags || []), ...(meme.contextual_tags || [])];
                this.state.tempUseCase = meme.use_case || '';
                // Use meme_type if available, otherwise derive from is_template
                this.state.tempMemeType = meme.meme_type || (meme.is_template ? 'customizable' : 'rec_engine');
                this.state.isEditingUseCase = false;

                // Initialize frontend tags categories (must match backend FRONTEND_TAGS)
                this.state.tempFrontendTags = { emotion: [], source: [], format: [], tone: [], situation: [], subject: [], vibe: [] };
                
                // Load frontend_tags from the dedicated field and categorize them
                const frontendTags = meme.frontend_tags || [];
                for (const tag of frontendTags) {
                    for (const [cat, tags] of Object.entries(this.state.frontendTagOptions)) {
                        if (tags.includes(tag)) {
                            this.state.tempFrontendTags[cat].push(tag);
                            break;
                        }
                    }
                }
                
                // Custom tags come from user_tags (descriptive tags like Gemini tags)
                this.state.tempCustomTags = [...(meme.user_tags || [])];
            },

            loadPendingMemeUI() {
                const meme = this.state.pendingMemes[this.state.currentIndex];
                if (!meme) return;

                this.state.currentMeme = meme;
                this.initTempData(meme);

                document.getElementById('currentMemeImage').src = meme.firebase_image_url || meme.image_url;
                document.getElementById('currentMemeId').textContent = meme.id;

                this.renderControls(document.getElementById('pendingControls'), 'pending');
            },

            renderControls(container, context) {
                const meme = this.state.currentMeme;
                const progress = context === 'pending' ? `${this.state.currentIndex + 1} of ${this.state.pendingMemes.length}` : '';
                const memeType = this.state.tempMemeType;

                container.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <h3 style="font-size: 15px;">Meme Details</h3>
                        <span class="progress-indicator">${progress}</span>
                    </div>

                    <!-- MEME TYPE TOGGLE -->
                    <div class="meme-type-toggle">
                        <span style="font-size: 12px; color: var(--text-secondary); margin-right: 8px;">Type:</span>
                        <button class="type-btn customizable ${memeType === 'customizable' ? 'active' : ''}" onclick="app.setMemeType('customizable')">
                            üé® Customizable
                        </button>
                        <button class="type-btn rec_engine ${memeType === 'rec_engine' ? 'active' : ''}" onclick="app.setMemeType('rec_engine')">
                            üöÄ Rec Engine
                        </button>
                        <button class="type-btn both ${memeType === 'both' ? 'active' : ''}" onclick="app.setMemeType('both')">
                            ‚ö° Both
                        </button>
                            </div>

                    <!-- GEMINI TAGS -->
                    <div>
                        <div class="section-header">ü§ñ Gemini Tags</div>
                        <div class="tags-container" id="geminiTagsContainer"></div>
                            </div>

                    <!-- GEMINI USE CASE -->
                    <div class="section-divider">
                        <div class="section-header">üí¨ Gemini Use Case</div>
                        <div class="use-case-box" id="useCaseBox"></div>
                        </div>

                    <!-- FRONTEND TAGS -->
                    <div class="section-divider">
                        <div class="section-header">üè∑Ô∏è Frontend Tags</div>
                        <div id="frontendTagsContainer"></div>
                    </div>

                    <!-- CUSTOM TAGS -->
                    <div class="section-divider">
                        <div class="section-header">‚úèÔ∏è Custom Tags</div>
                        <div id="customTagsContainer"></div>
                    </div>

                    <!-- ADD TAGS -->
                    <div class="section-divider">
                        <div class="section-header">‚ûï Add Tags</div>
                        <div class="category-filters" id="addTagCategories"></div>
                        <div class="input-group" style="margin-top: 10px;">
                            <input type="text" id="addTagSearch" placeholder="Search frontend tags..." autocomplete="off">
                        </div>
                        <div id="addTagSuggestions" class="suggested-tags-area" style="display: none; margin-top: 8px;"></div>
                        <div class="input-group" style="margin-top: 10px;">
                            <input type="text" id="customTagInput" placeholder="Type custom tag..." autocomplete="off">
                            <button class="btn btn-secondary" onclick="app.addCustomTag()" style="padding: 8px 14px;">Add</button>
                        </div>
                    </div>

                    <!-- ACTIONS -->
                    <div class="action-bar" id="actionBar"></div>
                `;

                this.renderGeminiTags(container);
                this.renderUseCase(container);
                this.renderFrontendTags(container);
                this.renderAddTagButtons(container);
                this.renderActionBar(container, context);

                // Search listener
                container.querySelector('#addTagSearch').oninput = (e) => this.searchAddTags(e.target.value, container);
                container.querySelector('#customTagInput').onkeypress = (e) => { if (e.key === 'Enter') this.addCustomTag(); };
                
                // Make sure suggestions are hidden initially
                const suggestions = container.querySelector('#addTagSuggestions');
                if (suggestions) suggestions.style.display = 'none';
            },

            renderGeminiTags(container) {
                const el = container.querySelector('#geminiTagsContainer');
                el.innerHTML = this.state.tempGeminiTags.map(tag => `
                    <span class="tag tag-gemini">
                        ${tag}
                        <span class="tag-remove" onclick="app.removeGeminiTag('${tag}')">√ó</span>
                    </span>
                `).join('') || '<span style="color: var(--text-secondary); font-size: 12px;">No Gemini tags</span>';
            },

            renderUseCase(container) {
                const box = container.querySelector('#useCaseBox');
                if (this.state.isEditingUseCase) {
                    box.innerHTML = `
                        <div class="use-case-display">
                            <textarea class="use-case-input" id="useCaseInput">${this.state.tempUseCase}</textarea>
                            <button class="edit-btn" onclick="app.saveUseCase()">Save</button>
                            <button class="edit-btn" onclick="app.cancelEditUseCase()">Cancel</button>
                        </div>
                    `;
                } else {
                    box.innerHTML = `
                        <div class="use-case-display">
                            <span class="use-case-text">${this.state.tempUseCase || 'No use case description'}</span>
                            <button class="edit-btn" onclick="app.editUseCase()">‚úèÔ∏è Edit</button>
                        </div>
                    `;
                }
            },

            editUseCase() {
                this.state.isEditingUseCase = true;
                const container = this.state.isModalOpen ? document.getElementById('modalControls') : document.getElementById('pendingControls');
                this.renderUseCase(container);
            },

            saveUseCase() {
                const container = this.state.isModalOpen ? document.getElementById('modalControls') : document.getElementById('pendingControls');
                this.state.tempUseCase = container.querySelector('#useCaseInput').value;
                this.state.isEditingUseCase = false;
                this.renderUseCase(container);
            },

            cancelEditUseCase() {
                this.state.isEditingUseCase = false;
                const container = this.state.isModalOpen ? document.getElementById('modalControls') : document.getElementById('pendingControls');
                this.renderUseCase(container);
            },

            setMemeType(memeType) {
                this.state.tempMemeType = memeType;
                const container = this.state.isModalOpen ? document.getElementById('modalControls') : document.getElementById('pendingControls');
                // Re-render the toggle buttons
                const toggleHtml = `
                    <span style="font-size: 12px; color: var(--text-secondary); margin-right: 8px;">Type:</span>
                    <button class="type-btn customizable ${memeType === 'customizable' ? 'active' : ''}" onclick="app.setMemeType('customizable')">
                        üé® Customizable
                    </button>
                    <button class="type-btn rec_engine ${memeType === 'rec_engine' ? 'active' : ''}" onclick="app.setMemeType('rec_engine')">
                        üöÄ Rec Engine
                    </button>
                    <button class="type-btn both ${memeType === 'both' ? 'active' : ''}" onclick="app.setMemeType('both')">
                        ‚ö° Both
                    </button>
                `;
                const toggleEl = container.querySelector('.meme-type-toggle');
                if (toggleEl) toggleEl.innerHTML = toggleHtml;
            },

            renderFrontendTags(container) {
                const el = container.querySelector('#frontendTagsContainer');
                let html = '';

                for (const [cat, config] of Object.entries(FRONTEND_CATEGORIES)) {
                    const tags = this.state.tempFrontendTags[cat] || [];
                    if (tags.length > 0) {
                        html += `<div style="margin-bottom: 8px;">
                            ${tags.map(tag => `
                                <span class="tag ${config.tagClass}">
                                    ${tag}
                                    <span class="tag-remove" onclick="app.removeFrontendTag('${cat}', '${tag}')">√ó</span>
                                </span>
                            `).join('')}
                        </div>`;
                    }
                }

                el.innerHTML = html || '<span style="color: var(--text-secondary); font-size: 12px;">No frontend tags</span>';
                
                // Also render custom tags
                this.renderCustomTagsDisplay(container);
            },

            renderCustomTagsDisplay(container) {
                const el = container.querySelector('#customTagsContainer');
                if (!el) return;
                
                if (this.state.tempCustomTags.length > 0) {
                    el.innerHTML = `<div style="display: flex; flex-wrap: wrap; gap: 8px;">
                        ${this.state.tempCustomTags.map(tag => `
                            <span class="tag tag-custom-display">
                                ${tag}
                                <span class="tag-remove" onclick="app.removeCustomTag('${tag}')">√ó</span>
                            </span>
                        `).join('')}
                    </div>`;
                } else {
                    el.innerHTML = '<span style="color: var(--text-secondary); font-size: 12px;">No custom tags</span>';
                }
            },

            renderAddTagButtons(container) {
                const wrapper = container.querySelector('#addTagCategories');
                let html = '';

                for (const [cat, config] of Object.entries(FRONTEND_CATEGORIES)) {
                    const tags = Array.isArray(this.state.frontendTagOptions[cat]) ? this.state.frontendTagOptions[cat] : [];
                    html += `
                        <div class="category-btn-wrapper">
                            <button class="category-btn ${config.btnClass}" onclick="app.toggleAddDropdown('${cat}', this)">
                                ${config.label}
                            </button>
                            <div class="category-dropdown">
                                ${[...tags].sort().map(tag => `
                                    <div class="dropdown-item" onclick="app.addFrontendTag('${cat}', '${tag}')">${tag}</div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                }

                // Custom dropdown
                const customTags = Array.isArray(this.state.customTags) ? this.state.customTags : [];
                html += `
                    <div class="category-btn-wrapper">
                        <button class="category-btn cat-btn-custom" onclick="app.toggleAddDropdown('custom', this)">
                            üè∑Ô∏è Custom
                        </button>
                        <div class="category-dropdown">
                            ${customTags.length > 0 ? [...customTags].sort().map(tag => `
                                <div class="dropdown-item" onclick="app.addExistingCustomTag('${tag}')">${tag}</div>
                            `).join('') : '<div style="padding: 8px; color: var(--text-secondary); font-size: 12px;">No custom tags yet</div>'}
                        </div>
                    </div>
                `;

                wrapper.innerHTML = html;
            },

            renderActionBar(container, context) {
                const actionBar = container.querySelector('#actionBar');
                if (context === 'pending') {
                    actionBar.innerHTML = `
                        <button class="btn btn-success" onclick="app.approveCurrent()" style="grid-column: span 3;">‚úÖ Approve & Next</button>
                        <button class="btn btn-danger" onclick="app.rejectCurrent()">‚ùå Reject</button>
                        <button class="btn btn-secondary" onclick="app.prevPending()">‚¨ÖÔ∏è Prev</button>
                        <button class="btn btn-secondary" onclick="app.skipCurrent()">Skip ‚û°Ô∏è</button>
                    `;
                } else {
                    actionBar.innerHTML = `
                        <button class="btn btn-primary" onclick="app.saveModalChanges()" style="grid-column: span 2;">üíæ Save Changes</button>
                        <button class="btn btn-danger" onclick="app.deleteCurrent()">üóëÔ∏è Delete</button>
                    `;
                }
            },

            // ================= TAG ACTIONS =================

            removeGeminiTag(tag) {
                this.state.tempGeminiTags = this.state.tempGeminiTags.filter(t => t !== tag);
                const container = this.state.isModalOpen ? document.getElementById('modalControls') : document.getElementById('pendingControls');
                this.renderGeminiTags(container);
            },

            removeFrontendTag(cat, tag) {
                this.state.tempFrontendTags[cat] = this.state.tempFrontendTags[cat].filter(t => t !== tag);
                const container = this.state.isModalOpen ? document.getElementById('modalControls') : document.getElementById('pendingControls');
                this.renderFrontendTags(container);
            },

            removeCustomTag(tag) {
                this.state.tempCustomTags = this.state.tempCustomTags.filter(t => t !== tag);
                const container = this.state.isModalOpen ? document.getElementById('modalControls') : document.getElementById('pendingControls');
                this.renderCustomTagsDisplay(container);
            },

            addFrontendTag(cat, tag) {
                if (!this.state.tempFrontendTags[cat].includes(tag)) {
                    this.state.tempFrontendTags[cat].push(tag);
                    const container = this.state.isModalOpen ? document.getElementById('modalControls') : document.getElementById('pendingControls');
                    this.renderFrontendTags(container);
                }
                document.querySelectorAll('.category-dropdown').forEach(el => el.classList.remove('show'));
            },

            addExistingCustomTag(tag) {
                if (!this.state.tempCustomTags.includes(tag)) {
                    this.state.tempCustomTags.push(tag);
                    const container = this.state.isModalOpen ? document.getElementById('modalControls') : document.getElementById('pendingControls');
                    this.renderCustomTagsDisplay(container);
                }
                document.querySelectorAll('.category-dropdown').forEach(el => el.classList.remove('show'));
            },

            async addCustomTag() {
                const container = this.state.isModalOpen ? document.getElementById('modalControls') : document.getElementById('pendingControls');
                const input = container.querySelector('#customTagInput');
                const tag = input.value.trim().toLowerCase();
                if (!tag) return;

                // Check if it's a frontend tag
                for (const [cat, tags] of Object.entries(this.state.frontendTagOptions)) {
                    if (tags.map(t => t.toLowerCase()).includes(tag)) {
                        const actualTag = tags.find(t => t.toLowerCase() === tag);
                        this.addFrontendTag(cat, actualTag);
                        input.value = '';
                    return;
                    }
                }

                // Check if already added
                if (this.state.tempCustomTags.includes(tag)) {
                    this.showToast('Tag already added', true);
                    input.value = '';
                    return;
                }

                // Add as custom - save to backend immediately
                this.state.tempCustomTags.push(tag);
                // Save to backend custom tags list immediately
                await this.saveCustomTag(tag);
                // Update the custom tags display
                this.renderCustomTagsDisplay(container);
                // Re-render the add tag buttons to show new custom tag in dropdown
                this.renderAddTagButtons(container);
                
                input.value = '';
                this.showToast('Custom tag added & saved to backend');
            },

            toggleAddDropdown(key, btn) {
                const dropdown = btn.nextElementSibling;
                const wasOpen = dropdown.classList.contains('show');
                document.querySelectorAll('.category-dropdown').forEach(el => el.classList.remove('show'));
                if (!wasOpen) dropdown.classList.add('show');
            },

            searchAddTags(query, container) {
                const q = query.toLowerCase().trim();
                const suggestions = container.querySelector('#addTagSuggestions');

                if (!q) { suggestions.style.display = 'none'; return; }

                const allTags = [...this.state.allFrontendTags, ...this.state.customTags];
                const matches = allTags.filter(t => t.toLowerCase().includes(q));

                if (matches.length === 0) { suggestions.style.display = 'none'; return; }

                suggestions.innerHTML = matches.map(tag => {
                    // Find category
                    let cat = 'custom';
                    for (const [c, tags] of Object.entries(this.state.frontendTagOptions)) {
                        if (tags.includes(tag)) { cat = c; break; }
                    }
                    return `<div class="preset-tag" onclick="app.addTagFromSearch('${cat}', '${tag}')">${tag}</div>`;
                }).join('');
                suggestions.style.display = 'flex';
            },

            addTagFromSearch(cat, tag) {
                const container = this.state.isModalOpen ? document.getElementById('modalControls') : document.getElementById('pendingControls');
                if (cat === 'custom') {
                    if (!this.state.tempCustomTags.includes(tag)) {
                        this.state.tempCustomTags.push(tag);
                        this.renderCustomTagsDisplay(container);
                    }
                } else {
                    this.addFrontendTag(cat, tag);
                }
                container.querySelector('#addTagSearch').value = '';
                container.querySelector('#addTagSuggestions').style.display = 'none';
            },

            // ================= SAVE / APPROVE =================

            async saveTags(memeId) {
                if (!memeId || !this.state.currentMeme) {
                    console.error('No meme to save');
                    return;
                }

                // Frontend tags (predefined) - used by rec engine for tag affinity
                const frontendTags = Object.values(this.state.tempFrontendTags).flat();

                // Custom tags - descriptive tags (like Gemini tags)
                const customTags = this.state.tempCustomTags || [];

                console.log('üíæ Saving tags for meme:', memeId);
                console.log('   Frontend tags:', frontendTags);
                console.log('   Custom tags:', customTags);
                console.log('   Visual/Gemini tags:', this.state.tempGeminiTags);

                // Save tags to backend
                const tagsRes = await fetch(`${API_BASE}/memes/${memeId}/tags`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        visual_tags: this.state.tempGeminiTags || [],
                        contextual_tags: [],
                        user_tags: customTags,        // Custom tags (descriptive)
                        frontend_tags: frontendTags   // For rec engine affinity
                    })
                });
                
                if (!tagsRes.ok) {
                    const err = await tagsRes.json();
                    throw new Error('Failed to save tags: ' + (err.detail || 'Unknown error'));
                }
                console.log('   ‚úÖ Tags saved');

                // Save use_case and meme_type (ALWAYS send these to ensure they're saved)
                const updates = {
                    use_case: this.state.tempUseCase,
                    meme_type: this.state.tempMemeType
                };
                
                console.log('   Saving use_case and meme_type:', updates);
                
                const fieldsRes = await fetch(`${API_BASE}/memes/${memeId}`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(updates)
                });
                
                if (!fieldsRes.ok) {
                    const err = await fieldsRes.json();
                    throw new Error('Failed to save fields: ' + (err.detail || 'Unknown error'));
                }
                console.log('   ‚úÖ Use case and meme_type saved');
            },

            async approveCurrent() {
                try {
                    if (!this.state.currentMeme || !this.state.currentMeme.id) {
                        this.showToast('No meme selected', true);
                        return;
                    }
                    const memeId = this.state.currentMeme.id;
                    
                    // Save all custom tags to backend first
                    for (const tag of (this.state.tempCustomTags || [])) {
                        await this.saveCustomTag(tag);
                    }
                    // Save tags to meme
                    await this.saveTags(memeId);
                    // Approve the meme
                    const res = await fetch(`${API_BASE}/memes/${memeId}/approve`, { method: 'POST' });
                    if (res.ok) {
                        this.showToast('Meme Approved! üéâ');
                        this.nextPending();
                    } else {
                        throw new Error((await res.json()).detail || 'Approval failed');
                    }
                } catch (err) {
                    console.error(err);
                    this.showToast('Error: ' + err.message, true);
                }
            },

            async rejectCurrent() {
                try {
                    if (!this.state.currentMeme || !this.state.currentMeme.id) {
                        this.showToast('No meme selected', true);
                    return;
                }
                    const memeId = this.state.currentMeme.id;
                    
                    const res = await fetch(`${API_BASE}/memes/${memeId}/reject`, { method: 'POST' });
                    if (res.ok) {
                    this.showToast('Meme Rejected');
                    this.nextPending();
                    } else {
                        throw new Error((await res.json()).detail || 'Reject failed');
                    }
                } catch (err) { 
                    this.showToast('Error: ' + err.message, true); 
                }
            },

            skipCurrent() { this.nextPending(); },

            prevPending() {
                if (this.state.currentIndex > 0) {
                    this.state.currentIndex--;
                    this.loadPendingMemeUI();
                } else {
                    this.showToast('This is the first meme');
                }
            },

            nextPending() {
                this.state.currentIndex++;
                if (this.state.currentIndex >= this.state.pendingMemes.length) {
                    this.loadMemes();
                } else {
                    this.loadPendingMemeUI();
                }
            },

            // ================= MODAL =================

            openModal(memeId) {
                const meme = this.state.approvedMemes.find(m => m.id === memeId);
                if (!meme) return;

                this.state.currentMeme = meme;
                this.state.isModalOpen = true;
                this.initTempData(meme);

                document.getElementById('modalMemeImage').src = meme.firebase_image_url || meme.image_url;
                document.getElementById('editModal').classList.add('active');

                this.renderControls(document.getElementById('modalControls'), 'modal');
            },

            closeModal() {
                document.getElementById('editModal').classList.remove('active');
                this.state.isModalOpen = false;
                this.state.currentMeme = null;
            },

            async saveModalChanges() {
                try {
                    // Save all custom tags to backend first
                    for (const tag of this.state.tempCustomTags) {
                        await this.saveCustomTag(tag);
                    }
                    // Save tags to meme
                    await this.saveTags(this.state.currentMeme.id);
                    this.showToast('Changes Saved! üíæ');
                    this.closeModal();
                    this.loadMemes();
                } catch (err) { this.showToast('Error: ' + err.message, true); }
            },

            async deleteCurrent() {
                try {
                    await fetch(`${API_BASE}/memes/${this.state.currentMeme.id}`, { method: 'DELETE' });
                    this.showToast('Meme Deleted üóëÔ∏è');
                    this.closeModal();
                    this.loadMemes();
                } catch (err) { this.showToast('Error: ' + err.message, true); }
            },

            // ================= APPROVED VIEW FILTERING =================

            renderCategoryButtons() {
                const container = document.getElementById('categoryFilters');
                if (!container) return;

                let html = '';
                for (const [cat, config] of Object.entries(FRONTEND_CATEGORIES)) {
                    const tags = Array.isArray(this.state.frontendTagOptions[cat]) ? this.state.frontendTagOptions[cat] : [];
                    if (tags.length === 0) continue;

                    html += `
                        <div class="category-btn-wrapper">
                            <button class="category-btn ${config.btnClass}" onclick="app.toggleFilterDropdown('${cat}')">
                                ${config.label}
                            </button>
                            <div id="filter-dropdown-${cat}" class="category-dropdown">
                                ${[...tags].sort().map(tag => `
                                    <div class="dropdown-item" onclick="app.addFilter('${tag}')">${tag}</div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                }
                container.innerHTML = html;
            },

            toggleFilterDropdown(key) {
                const dropdown = document.getElementById(`filter-dropdown-${key}`);
                const wasOpen = dropdown.classList.contains('show');
                document.querySelectorAll('.category-dropdown').forEach(el => el.classList.remove('show'));
                if (!wasOpen) dropdown.classList.add('show');
            },

            searchFilterTags(query) {
                const q = query.toLowerCase().trim();
                const container = document.getElementById('suggestedTags');

                if (!q) { container.style.display = 'none'; return; }

                const matches = [...this.state.allFrontendTags].filter(t => t.toLowerCase().includes(q));

                if (matches.length === 0) {
                    container.innerHTML = '<span style="color:var(--text-secondary); font-size:12px;">No matching tags</span>';
                    container.style.display = 'flex';
                    return;
                }

                container.innerHTML = matches.map(tag => `
                    <div class="preset-tag" onclick="app.addFilter('${tag}')">${tag}</div>
                `).join('');
                container.style.display = 'flex';
            },

            addFilter(tag) {
                if (!this.state.activeFilters.includes(tag)) {
                    this.state.activeFilters.push(tag);
                    this.renderActiveFilters();
                    this.applyFilters();
                }
                document.querySelectorAll('.category-dropdown').forEach(el => el.classList.remove('show'));
                document.getElementById('tagSearchInput').value = '';
                document.getElementById('suggestedTags').style.display = 'none';
            },

            removeFilter(tag) {
                this.state.activeFilters = this.state.activeFilters.filter(t => t !== tag);
                this.renderActiveFilters();
                this.applyFilters();
            },

            renderActiveFilters() {
                const container = document.getElementById('activeFilters');
                container.innerHTML = this.state.activeFilters.map(tag => `
                    <div class="filter-tag">
                        ${tag}
                        <span style="cursor:pointer;font-weight:bold" onclick="app.removeFilter('${tag}')">√ó</span>
                    </div>
                `).join('');
            },

            applyFilters() {
                let filtered = [...this.state.approvedMemes];

                // Sort by approved_at date (most recent first)
                filtered.sort((a, b) => {
                    const dateA = a.approved_at ? new Date(a.approved_at) : new Date(0);
                    const dateB = b.approved_at ? new Date(b.approved_at) : new Date(0);
                    return dateB - dateA;
                });

                // Apply approved filter (last 1, 5, 10 or meme type)
                const filter = this.state.approvedFilter;
                if (filter === 'last1') {
                    filtered = filtered.slice(0, 1);
                } else if (filter === 'last5') {
                    filtered = filtered.slice(0, 5);
                } else if (filter === 'last10') {
                    filtered = filtered.slice(0, 10);
                } else if (filter === 'customizable') {
                    filtered = filtered.filter(m => m.meme_type === 'customizable' || m.meme_type === 'both');
                } else if (filter === 'rec_engine') {
                    filtered = filtered.filter(m => m.meme_type === 'rec_engine' || m.meme_type === 'both' || !m.meme_type);
                } else if (filter === 'both') {
                    filtered = filtered.filter(m => m.meme_type === 'both');
                }

                // Apply tag filters
                if (this.state.activeFilters.length > 0) {
                    filtered = filtered.filter(meme => {
                        const memeTags = [...(meme.visual_tags || []), ...(meme.contextual_tags || []), ...(meme.user_tags || [])];
                        return this.state.activeFilters.every(filter => memeTags.includes(filter));
                    });
                }

                this.renderApprovedGrid(filtered);
            },

            setApprovedFilter(filter) {
                this.state.approvedFilter = filter;
                // Update button states
                document.querySelectorAll('.approved-filters .filter-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.onclick.toString().includes(`'${filter}'`)) {
                        btn.classList.add('active');
                    }
                });
                this.applyFilters();
            },

            renderApprovedGrid(memes) {
                const grid = document.getElementById('approvedGrid');
                if (memes.length === 0) {
                    grid.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: var(--text-secondary); padding: 40px;">No memes found</div>';
                    return;
                }

                const getTypeBadge = (memeType) => {
                    if (memeType === 'customizable') return '<span style="background:#30D158;color:white;padding:2px 6px;border-radius:4px;font-size:10px;">üé®</span>';
                    if (memeType === 'both') return '<span style="background:#5E5CE6;color:white;padding:2px 6px;border-radius:4px;font-size:10px;">‚ö°</span>';
                    return '<span style="background:#FF9F0A;color:white;padding:2px 6px;border-radius:4px;font-size:10px;">üöÄ</span>';
                };

                grid.innerHTML = memes.map(meme => `
                    <div class="meme-card" onclick="app.openModal('${meme.id}')">
                        <img class="card-img" src="${meme.firebase_image_url || meme.image_url}" loading="lazy">
                        <div class="card-body">
                            <div class="card-meta">
                                <span>${getTypeBadge(meme.meme_type || 'rec_engine')}</span>
                                <span>üëÅÔ∏è ${meme.total_views || 0}</span>
                            </div>
                            <div class="card-tags">
                                ${(meme.frontend_tags || meme.user_tags || []).slice(0, 3).map(t => `<span class="mini-tag">${t}</span>`).join('')}
                            </div>
                        </div>
                    </div>
                `).join('');
            },

            // ================= TAGS VIEW =================

            renderTagsView() {
                const container = document.getElementById('customTagsList');
                const customTags = Array.isArray(this.state.customTags) ? this.state.customTags : [];
                
                if (customTags.length === 0) {
                    container.innerHTML = '<p style="color:var(--text-secondary)">No custom tags yet.</p>';
                    return;
                }

                container.innerHTML = [...customTags].sort().map(tag => `
                    <div class="tag tag-custom" style="font-size:14px; padding:8px 12px;">
                        ${tag}
                        <span class="tag-remove" onclick="app.deleteCustomTag('${tag}')" style="margin-left:8px; font-size:16px;">√ó</span>
                    </div>
                `).join('');
            },

            async deleteCustomTag(tag) {
                try {
                    await fetch(`${API_BASE}/tags/custom/${encodeURIComponent(tag)}`, { method: 'DELETE' });
                    this.state.customTags = this.state.customTags.filter(t => t !== tag);
                    this.renderTagsView();
                    this.showToast('Tag deleted');
                } catch (err) { this.showToast('Error: ' + err.message, true); }
            },

            async clearAllCustomTags() {
                if (!confirm('Delete ALL custom tags?')) return;
                try {
                    // Clear all at once by posting empty array
                    await fetch(`${API_BASE}/tags/custom`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify([])
                    });
                    this.state.customTags = [];
                    this.renderTagsView();
                    this.showToast('All custom tags deleted');
                } catch (err) { this.showToast('Error: ' + err.message, true); }
            },

            showToast(msg, isError = false) {
                const toast = document.getElementById('toast');
                toast.textContent = msg;
                toast.style.background = isError ? '#FF453A' : '#3A3A3C';
                toast.classList.add('show');
                setTimeout(() => toast.classList.remove('show'), 3000);
            }
        };

        window.addEventListener('DOMContentLoaded', () => app.init());
    </script>
</body>
</html>
